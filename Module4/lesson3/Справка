Ну что. Прошлый файл справки на 300 строк изучен? Отлично. Но теперь, вместо 7 часов у меня ролик на 11 часов + 3.5 часа + 1.5 часа + 0.5 часа, так что строк здесь будет... Ну раза в 
2 больше. Удачи мне! 
P.S Это по Jango 


В папке templates-for-Django... находится верстка сайта. Делал её не я, а автор видика.

Первым делом, надо установить расширение для Django От baptise darthenay (думаю тут проблем не возникнет)



1. Создание виртуального окружения (это для windows, для linux/mac команды другие)
    1. В терминале прописываю: python -m venv venv 
    2. Там же активирую окружение: venv\Sctipts\activate 
        P.S если вылетает такая ошибка:
            venv\Scripts\activate : Невозможно загрузить файл C:\Users\User\lesson3\venv\Scripts\Activate.ps1, так как выполнение сценариев 
            отключено в этой системе. Для получения дополнительных сведений см. about_Execution_Policies по адресу https:/go.microsoft.com/fwlink/?LinkID=135170.
        То:
            Открыть powershell от администратора, вписать:
            Set-ExecutionPolicy RemoteSigned
            Ответить A 
    
2. Установка django:
    pip install Django (в терминале)

3. Создание проекта:
    django-admin startproject NameOfProject (в терминал)

4. Перейти в папку проекта:
    cd ./NameOfProject

5. Что бы сделать виртуальное окружение постоянно активным:
    1. Просто откроем файл manage.py в папке проекта
    2. В vs code снизу написан интерпретатор - python 3.12. Нажимаю на него 
    3. Выбираю введите путь к интерпретатору
    4. Нажимаю найти
    5. Выбираю venv - Scripts - python.exe

6. Запуск локального сервера:
    python manage.py runserver (в терминал)

    После этого появится "ошибка" you have 18 unapplied migrations... Сейчас на нее внимание не обращаю, что бы открыть сервер - ctrl и клик на адрес 

7. Следущим этапом надо автоматизировать запуск сервера по комбинации клавиш:
    1. В vs code выбрать в левом баре Run and Debag, и нажимаю launch.json file, python debugger, django.



Какие файлы содержатся в NameOfProject:
    __init__.py - сообщает Python, что все файлы в папке взаимосвязаны
    asgii, wsgi - отвечают за то, ассинхронный и синхронный способ общения django с сервером. Для онлайн-чатов - asgi, для обычного интернет-магазина - wsgi 
    urls.py - ссылки в приложении. По умолчанию есть маршрут admin - то есть если в браузере вписать хост/admin, то откроется вход в панель админа от джанго (встроенный)
    settings.py - все настройки проекта:
        Пару переменных из него:
            base_dir - переменная с путем до каталога проекта
            secret_key - секретный ключ, что позволяет корректно работать. Каждый раз генирируется
            debug - включена/выключена отладочная информация (при разработке - True, при деплойте - True)
            Installed_apps - установленные приложения в проекте (логические блоки в web приложении)
            root_urlconf - все url адреса приложения 
            templates - шаблонизатор с наполнением приложения 
            Databases - подключение баз данных 
            static_url - адрес для получения статик файлов 


8. Создание приложения:
    python manage.py startapp NameOfApp (в терминал)
    Сразу же регистрирую его в проекте:
        В файл settings.py В insalled_apps дописываю имя приложения


Файлы внутри приложения:
    Папка migrations - там применяются файлы миграции, то есть файлы, которые будут прописывают, какие таблицы будут создаваться в БД по надобности
    __init__ - То же, что и раньше 
    admin - файл для регистрации таблиц в админ панели 
    apps - настройки и конфигурация приложения 
    models - Описание, какие таблицы будут храниться и для чего
    test - написание автоматизированных тестов проверки кода на работоспособность 
    views - функции/классы, отрабатывающие запросы пользователя. Запрашивает данные из бд и записывает в Models.py, обрабатывается, и передается в templates, затем возвращает ответ в виде страницы

    


Архитектура MTV (Model Template View): 
    Как происходит взаимодействие при запросе страницы:
        Пользователь запрашивает страницу main (проще говоря, переходит по ссылке на эту страницу). Тогда django, отбросив домен, просматривает, есть ли в urls.py такая страница main. 
        Если он находит там необходимый маршрут, то вызывается функция, или класс, описанные во views.py этого приложения, и эта функция исполняет ответ:
            Запрашивает данные из базы данных и записывает этот код в models.py, информация возвращается в функцию. Там она обрабатывается. Затем эта информация передается в templates - пустой 
            html шаблон заполняется обработанной информацией и возвращается в views. Там спец. функция - контроллер, или представление, возвращает response (ответ) - готовую страницу пользователю




Приложение main:
    1. Конечно после создания регистрируем его в settings проекта, в insalled_apps
    2. Создаю контроллер, который будет обрабатывать запросы в views.py ( функция index ). Так же небходимо импортировать HttpResponse -> from django.http import HttpResponse
    3. Закрепляю контроллер за url адресом:
        В urls.py есть коллекция urlpatterns. Добавляю в нее маршрут: у нас есть доменное имя - https://name_of_host . Я добавляю в нее path('a',func) где:
            a - это страница: то, что будет идти после домена. 
                Ну например есть главная страница - https://name_of_host/ . Значит для нее a это ничего. path('', func)
                А для страницы account - https://name_of_host/account. Значит для страницы аккаунта a = account    =>    path('account', func, name)
            func - это ссылка на контроллер для этой страницы:
                Для главной страницы контроллер - index, он лежит в views папки main. Значит я импортирую файл views в файл settings: from main import views, и записываю ссылку: path('',views.index)
                Для account контроллер - auth => from user import views, path('account', views.account)
            name = 'name' - имя, необходимое для последующего использования в шаблонах (например если ссылка на страницу изменится, а обращались мы всегда по имени, имя во всем коде не придется менять)
    4. В директории приложения создаем папку для html - templates. Т.к приложений может быть много, а файлы html могут иметь одно название, то внутри целесообразно создать еще одну - с названием приложения
        То есть в директории main создаю папку templates, а в папку templates создаю папку main. В эту папку перекидываю все html файлы для этого приложения 
    5. В views.py для отображения страницы return HttpResponse('home page') меняем на return render(request, 'path_to_html'). Из названия понятно, что ф-я render отображает html страницу. 1 аргументом
        всегда передаю request, вторым - путь до html файла (в данном случае получится return render(request, 'main/index.html'))
        Так же можно передать в render context - это словарь, который я сам пишу внутри контроллера. Например:
        context = {
            'title': 'Home',
            'content': 'Главная страница магазина - HOME'
        }
        return render(requet, 'main/index.html', context)

        Но при загрузки страницы этих данных я не увижу, что бы их получить:
            в index.html, в теге title я пишу {{ title }}
            в теге body пишу {{ content }}

        При обновлении я их увижу. Но для качественного примера, нужно добавить в context еще пару значений:
        context = {
            'title': 'Home', 
            'content': 'Главная страница магазина - HOME',
            'list': ['first', 'second'],
            'dict': {'first':1},
            'bool': True
        }

        Тогда, если я в body напишу:
            <p> {{ content }} </p>
            <p> {{ list }} </p>
            <p> {{ dict }} </p>
            <p> {{ bool }} </p>

        То получу такую страницу:
            Главная страница магазина - HOME 
            ['first', 'second']
            {'first':1}
            True 

        Конечно мне нужны именно значения, а не сами списки, словари и сырые данные. НО. Что бы их получить, например, из словаря, я пишу не dict.get(first), а dict.first. Не list[0], а list.0 :
            <p> {{ content }} </p>
            <p> {{ list.0 }} </p>
            <p> {{ dict.first }} </p>
            <p> {{ bool }} </p>

        Тогда я получаю правильный вывод:
            Главная страница магазина - HOME
            first
            1
            True



        Другие примеры шаблонных тегов:
            {% if a>b %}
                <p> a больше b </p>
            {% endif %}

                То есть, например, в context (в views.py ) у меня добавлено 'is_authetificated':True, то при
                    {% if is_authetificated %}
                        <p> Вы авторизованы !!! </p>
                    {% endif %}
                
                Выведется на странице 
                    Вы авторизоваваны !!!


