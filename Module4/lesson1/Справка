Ассимптотическая сложность алгоритмов.

Асимптотическая сложность — это способ подсчета необходимых вычислительных ресурсов (время, память) во время выполнения программы.

    Приемлимыми считаются сложнысти до квадратичной, или N**2. Если сложность выше - то программа считается неэффективной и требует переработки.
        Виды приемлемых сложностей:
            Константная;        O(1)
            Логарифмическая сложность, или log(N);  O(log N)
            Линейная, или N;    O(N)
            Линейно-логарифмическая N * log(N);     O(N * log N)
            Квадратичная, или N**2; O(N**2)

Пример оптимизации программы: в файле main.py я использовал двойной цикл for - что являлось квадратичной сложностью. Однако, добавив set, она стала в районе от O(k * N) до O(N**2). 
    
    Во первых, что делает функция set():
        Функция set() преобразует передаваемые в нее элементы в множество с уникальными значениями. Если передать строку - set разобьет ее на символы и оставит только уникальные.

    Во вторых что такое сложность O(k*N):
        
        Стоит уточнить, что k - кол-во уникальных символов в строке, N - кол-во символов в строке. 
        
        O(k*N) - это линейно-зависимая сложность с доп. фактором k. И если k - то есть кол-во уникальных символов в строке, по сравнению с N - кол-вом символов в строке сильно маленькое, то сложность
            будет приближена к линейной. Если же k близится к равенству N или вовсе равно N, то это будет приближенная к квадратичной сложности или ей и являться. 

        Таким образом получается, что с помощью set ТОЛЬКО В 5 строке, (если его добавить ниже результат будет не верным), я в худшем случае не изменил скорость работы программы, а в лучшем значительно
            ее уменьшил.



#=========================================================================================================================================================================================================



GIT:

Что бы скачать git, нужно перейти на сайт: https://git-scm.com/

Что бы "запушить" код на github, нужно:
1. Открыть git bash

2. Задать свои имя и почту:
    git config --global user.name "Имя"
    git config --global user.email "email"

3. Перейти на github, создать репозиторий и скопировать на нее ссылку. Она будет в формате:
    https://github.com/NameOfProfile/NameOfRepository.git

4. Перейти в корневую папку с кодом:
    cd /c/path_to_code

5. Создать локальный репозиторий:
    git init

6. Связать локальный репозиторий и удаленный:
    git remote add origin ссылка_на_репозиторий (из шага 3)

7. Создать файл .gitignore и вписать внего вручную (открыть файл и вписать) пути из корневой папки до файлов, которые не должны попасть на гит (токены например)
    touch .gitignore 
    Открыть файл и вписать пути 

8. Добавить файлы в локальный репозиторий:
    git add name_of_file 
    Вместо name_of_file можно просто написать . тогда все файлы из корневого каталога добавятся

8. Написать коммит - описание изменений
    git commit -m "Коммит"

9. Проверить, в какой ветке git я работаю: 
    git branch

10. Запушить код в репозиторий:
    git push -u origin ИМЯ_ВЕТКИ

11. Подтвердить, что у вас есть доступ к репозиторию (просто нажать в выпавшем окне auth with browser и войти в свою учетную запись github)

12. Проверить, что пуш удался.

13. Дальше, после обновления кода, просто надо открыть git bash, перейти в директорию с кодом, локальный репозиторий уже создан из прошлых шагов, и повторить шаги 4, 8 и 10.




Если работать не в одиночку, а с несколькими людьми, то пользоваться способом выше неправильно (Могут потеряться изменения других разработчиков). В таком случае:
    1. Необходимо создать отдельную ветку с описанием, что делаешь конкретно ТЫ
        git checkout -b feauture/описание 

    2. Дальше работать в ней:
        git add .
        git commit -m "Коммит"

    3. Регулярно проводить синхронизацию с веткой main/master, что бы работать с актуальной версией кода (вдруг пока я писал код, уже обновили основной другими изменениями другого разработчика)
        3.1 Выбрать основную ветку
            git checkout main 
        3.2 Вытянуть последние измения из основного кода 
            git pull origin main 
        3.3 Переключиться обратно в вашу ветку:
            git checkout feauture/описание 
        3.4 Слить изменения из основной ветки в мою:
            git merge main 

    4. Когда я закончил работу, необходимо запушить код в мою ветку, не в main/master 
        git push origin feauture/описание

    5. Создать Pull Request (запрос слияния) на github 
        Перейти в Github в репозиторий 
        Найти мою рабочую ветку 
        Нажать "Compare & Pull Request"
        Описать изменения и отправить запрос. Его проверят на ошибки, на конфликты, и если таковые есть - отклонят и отправят на переработку, если не - подтвердят. 




Примерный рабочий процесс в команде:

    Клонировать репозиторий или скачать последние изменения:
        git clone https://github.com/ваш_пользователь/репозиторий.git

    Создать ветку для работы:
        git checkout -b feature/название-фичи

    Работать в этой ветке, делать изменения, коммитить:
        git add .
        git commit -m "Описание изменений"

    Регулярно синхронизироваться с основной веткой:
        git checkout main
        git pull origin main
        git checkout feature/название-фичи
        git merge main

    Пушить изменения в свою рабочую ветку:
        git push origin feature/название-фичи

    Создавать Pull Request на GitHub для слияния с основной веткой.

    После слияния PR обновить локальную основную ветку:
        git checkout main
        git pull origin main
