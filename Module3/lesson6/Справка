Геттер - функция, возвращающая какое-либо значение атрибута.
Сеттер - функция, устанавливающая какое-либо значение атрибуту.
Делитер - функция, определяющая поведение при удалении атрибута или метода.

Параметры доступа: 

    def __init__(self,a,b,c):
        self.a = a      - доступ к атрибуту класса есть из любой точки кода, public
        self._b = b     - доступ к атрибуту есть только из класса и его подклассов, protected
        self.__c = c    - доступ к атрибуту есть только из данного класса, private

    Как я уже ранее говорил, как таковой инкапсуляции в python нет, и подчеркивания - это в основном предостережения для программистов. 


Геттеры, сеттеры.
Допустим, что все таки необходимо дать возможность другим юзерам использовать _ методы. Тогда, что бы они ничего не ломали, нужно написать геттеры и сеттеры для изменения этих атрибутов 

    def set_nums(self, new_a, new_b, new_c):
        self.a = new_a
        self._b = new_b
        self.__C = new_c


    def get_nums(self)
        return self.a, self.new_b, self.__c



Теперь другой пользователь в любой момент может вызвать сеттер set_nums и геттер get_nums для изменения и получения атрибутов:

    numbers = Nums(1,2,3)
    print(numbers.get_nums())   # 1 2 3. Использую геттер для получения значений a, b и c
    numbers.set_nums(4,5,6)     # Использую сеттер для изменения значений a, b и с
    print(numbers.get_nums())   # 4 5 6. Использую геттер для проверки, что все получилось


Однако вы можете спросить: и все-таки, зачем делать закрытые атрибуты, а потом еще и писать методы для того, что бы ими могли пользоваться? Я отвечу: с помощью сеттера и геттера мы можем исключить
ошибки и исключения. Допустим, что метод должен из c вычитать b. Тогда, если пользователь, другой программист или еще кто-то введет не число, а, например, строку, то программа рухнет с 
непонятным для юзера исключением. А я в сеттере проверю, что вводятся именно числа, и если нет, выведу исключение, понятное любому: 

def set_nums(self, new_a, new_b, new_c):
    if type(a) in (int, float) and type(b) in (int, float) and type(c) in (int, float):
        self.a = new_a
        self._b = new_b
        self.__C = new_c
    else:
        raise Exception('Должно быть введено число! Убедитесь в правильности ввода!!! ')

А для геттера, например, можно ввести проверку роли. И если у него, допустим, роль админа - он может получить значения аргументов, а иначе - вызвать исключение



=======================================================================================================================================================================================================



Декоратор @property

Декоратор @property так же помогает работать с сеттерами и геттерами, за одним исключением: если без property мы вызываем метод для получения/изменения аргумента, то в property мы работаем как-будто
с переменной.

Для начала пишется геттер (метод геттера и сеттера должны иметь одно имя, позже поймешь):
    
    @property
    def mymethod(self)
        return self.__a


Затем пишется сеттер, но вместо property мы в декоратор пишем название геттера.setter:

    @mymethod.setter
    def mymethod(self, new_a)    
        if type(a) in (int, float):
            self.__a = new_a
        else:
            raise Exception('a должно быть числом!!!')



Теперь, что бы изменить или получить защищенные a и b, мы пишем:

    numbers = Nums(4)
    numbers.mymethod = 6    #Изменяем число
    print(numbers.mymethod) #Получаем число



Я немного устал, но все исключения будут работать так, как надо. Можешь проверить