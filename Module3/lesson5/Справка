Контекст-менеджер = это объект Python, который следит за инициализацией и финализацией данного контекста, то есть определяет действия, которые должны произойти до и после выполнения блока кода.





Почему None?
    
    Итак, есть контекст менеджер (строки 1 - 24). При его использовании таким образом:

        with Time_working():
            num_list = [i for i in range(100_000_000)] 


    Получается правильный результат: такой, как указан внутри контекст-менеджера и какой я ожидал. Однако, если использовать его так:
        
        with Time_working() as t1:
            num_list = [i for i in range(100_000_000)]


    Возвращается None. А если добавить следущую строчку:
        
        with Time_working as t1:
            num_list = [i for i in range(1_000_000)]   
            print(t1)   


    То вывод будет None, и ожидаемый результат. Почему? Давай посмотрим на контекст-менеджер. Метод __enter__ ничего не возвращает - в нем нету return => return None. Если я, например, напишу в 
    конце этого метода return 1, то вывод будет 1 и ожидаемый результат. А если return self? То выведется ячейка памяти. Причем с каждой инициализацией эта ячейка будет разная. По сути, return
    писать не обязательно.





Метод __exit__ - специальный метод, который очищает контекст, созданный методом __enter. Он выполняется даже в случае исключений

    Параметры метода __exit__ (обязательны, может быть другое название, но 3 аргумента + self должны быть обязательно):

        exc_type - тип исключения
        exc_val - значение исключения
        exc_val - объект трассировки

    Попробую вызвать исключение (43 - 46 строки), а так же добавим print параметров метода __exit__ (21 - 23 строки) в контекст-менеджер (), результат:

    Видно, что контекст-менеджер и правда может отлавливать исключения, еще и после него он продолжит выполнять оставшийся код. Но зачем? Я же не совсем криворукий, напишу без исключений
    и код будет работать правильно. Так смысл? Но если я хочу, что бы мне было все равно? Ну есть ошибка, ну и пусть. Я увидел, окей, но пусть код продолжает работать дальше. 
    
    Так вот: теперь надо это исключение заглушить:
        if exc_type is TypeError:
            return True


    А если я хочу исключить любое исключение? Да все просто:
        if exc_type is not None:
            return True

    НО!!! Не стоит этим злоупотреблять. Потому что мало того, что часть кода, вызывающая исключение, не работает, так еще и в любом случае ясно - код написан НЕ ПРАВИЛЬНО. В основном это необходимо
    для готового продукта, например, для приложения. Юзер пользовался им, что то нажал и у него исключение, приложение вылетело. Естесственно он будет не доволен. Уж лучше пусть код не выполнится,
    чем у него вылетит с каким-то не найденым тестировщиками, и не продуманным программистом исключением.



=======================================================================================================================================================================================================
Итератор - объект, реализующий метод __next__, который должен вернуть либо следущий элемент, либо выдать исключение StopIteration/
Итерируемый объект - объект, от которого встроенная функция iter() может получить итератор.
StopIteration - исключение, вызывающиеся при полном опустошении итератора.
    Итераторы имеют свойство опустошаться. Из-за этого их необходимо перезагружать. Обычно это делают в методе __iter__
По сути, цикл for - это цикл while, внутри которого реализован итератор и метод __next__
