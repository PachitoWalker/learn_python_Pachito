# Создаем функцию генератор
def my_gen():
    for x in range(10):
        print(x)

print('Используем print')
my_gen()                    # просто выведет числа от 1 до 9, ничего не вернет
print('Готово \n',50*'=')



def my_generat():
    for i in range(10):
        return i 

print('Используем return')
my_generat()                # Ничего не вывелось? А, точно, ведь нет нигде принта
print('Готово \n',50*'=')
print('Используем print() с return')
print(my_generat())         # Странно. Вывелся только 0. А теперь вспомним, что return - выход из функции.
print('Готово \n',50*'=')
print('А если попробовать зациклить функцию?')
# for k in my_generat():    # Ну конечно же не работает. Ведь если из функции выходишь, то там только 1 число. Естесственно в этом числе не может ничего быть
#     print(k)



# А вот и решение
def my_generator():
    for j in range(10):
        yield j

# Хм, а вдруг... Зациклим еще раз? Я же дурак, наступаю на одни и те же грабли. Так что... 
print('Используем yield с print()')
for x in my_generator():
    print(x)                # СРАБОТАЛО!!! Но почему? Как не странно, это главный вопрос программиста) но все таки в Справке этот момент я объясню
print('Готово \n',200*'=', '\n', 200 * '=')



# Так что же это за yield?

# Это поможет 
def my_bred():
    for j in range(10):
        print(f'До {j}')
        yield j
        print(f'После {j}')

for x in my_bred():
    print(x) 

# Ну-ка ну-ка. Смотрите. Функция вывела 'До J', отдала значение j и потом, не как return - завершила работу, а продолжила ее. А теперь прочитай в Справке Как работает yield