Магический метод __add__ позволяет указать, как должно работать сложение с объектами класса. Описывается он примерно таким образом:
    def __add__(self,other):    где self - объект нынешнего класса, other - другой объект, может быть как нынешнего, так и другого класса.
        if isinstance(other, NameOfClass)    - isinstance проверяет, пренадлежит ли other классу NameOfClass, и возвращает True или False. То есть в данной строке если other принадлежит NameOfClass, то 
            return self.param + other.param     - возвращает сумму указанных нами параметров объктов.

    Если, например, я складываю параметр объекта с целым числом, то
        if isinstance(other, int):
            return self.patam + other       - так как other - класс int 

    Вызывать __add__ не нужно: он используется автоматически, если мы к экземпляру (объекту) класса прибавляем что-то. 

    c = a + b       Если a - объект класса NameOfClass, а b - целое число, то эта строка равнозначна c = a.param + b




Алхимия: 
    Структура: 
        Создание окна, задание его размеров
        Создание классов каждого элемента, в которых объявляется:
            картинка класса, и какой элемент получится, если элемент данного класса сложить с элементом другого класса 
        Написание функции move для перетаскивания объектов
            Проверка соединения элементов, наличия такого же элемента на холсте, и если такого элемента нет - то добавить его на холст
        Создание и размещение холста
        Создание списка с объектами начальных элементов и размещение их на холсте
        Бинд для вызова функции move
        window.mainloop


Структура класса:

    Передаем в виждет картинку: tkinter.PhotoImage(file="path_to_file")

    Пишем метод __add__ для получения новых элементов (когда мы будем наводить картинку одного элемента на другой, они будут "складываться" и возвращать новый элемент)
        def __add__(self, other):
            if isinstance(other, NameOfSecondClass):            если данный элемент складывается с нужным (например вода + огонь = пар, текущий класс - Вода, тогда NameOfSecondClass - Огонь). 
                                                                в случае добавления новых возможных элементов с данным, просто пишем то же самое с elif
                return NameOfNewElementClass()
            else:                                               else используем, что бы не было ошибок при сложении элементов, которые ничего не дают
                pass

    Примечание: isinstance пишется для обоих классов (в примере с огнем и водой, то в огонь пишется isinstanse(other, Water), а в воду isinstance(other, Fire))

Cтруктура move(event) где event - курсор:
    
    find_overlapping() принимает координаты x1, y1, x2, y2 и создает в этих координатах "квадрат" на холсте. Если в этом квадрате появляются объекты, то этот метод возвращает его id (в виде кортежа)
    coords() принимает 3 аргумента: IdObject, x2 и y2, где IdObject - id объекта, x2 и y2 - новая координата объекта. Этот метод перемещает объект на x и y
    create_image() принимает три аргумента: x, y и NameOfPhoto. Этот метод размещает фото (Из tkinter.PhotoImage) на координаты x и y 

    Итак: эта функция запускается постоянно, пока нажата забинженная кнопка (Позже об этом). 
    В начале мы создаем область, в которой находится курсор, и если в области курсора будет какой-либо объет, то вернуть его id:
        images_id = canvas.find_overlapping(event.x, event.y, event.x + 10, event.y + 10). 

    Затем перемещаем объкт по id вслед за курсором, если он попал в область
        canvas.coords(images_id[0], event.x, event.y)

    Дальше создаем соединение элементов: Если в области курсора 2 элемента - то они соединяютася:
        if len(images_id) = 2:
            
            Далее перемещаем id обоих объектов в переменные, и получаем их из списка, который будет ниже (сильно ниже, не в структуре move):
                elem_id_1 = images_id[0]
                elem_id_2 = images_id[1]

                element1 = elements[elem_id_1 - 1]
                element2 = elements[elem_id_2 - 1]

            Создаем новый элемент:
                newelement = element1 + element2 

            Если появляется новый элемент:
                if newelement:
                
                То сначала кладем в массив названия классов всех уже созданных элементов и проверяем, что такого элемента еще нету на холсте (не создавали)
                    
                    element_types = []
                    for elem in elements:
                        element_types.append(type(elem))

                    Если такой элемент уже есть, то ничего не делать:     
                    if type(new_element) in element_types:
                        pass 

                    Если же такого элемента нет, то размещаем на холсте на координатах курсора его изображение, затем добавляем в список уже созданных элементов    
                    else:   
                        canvas.create_image(event.x, event.y, image = new_element.image)
                        elements.append(new_element)
                       

Остальная часть программы: 
    Создание и размещение холста:
        canvas = tkinter.Canvas(window, width = 800, height= 700)   
        canvas.pack()


    Создание списка с начальными элементами:
        elements = [Earth(), Water(), Wind(), Fire()]


    Размещение начальных элементов из списка на холсте
        for elem in elements:
            canvas.create_image(random.randint(50, 750), random.randint(50, 650), image = elem.image)


    Бинд левой кнопки мыши на функцию move (перемещение картинок и их соединение => создание новых элементов(их картинок))
        window.bind('<B1-Motion>', move)


    Ну постоянное обновление окна:
        window.mainloop()
